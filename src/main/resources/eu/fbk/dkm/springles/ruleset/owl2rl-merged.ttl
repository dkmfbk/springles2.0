@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix spr:  <http://dkm.fbk.eu/springles/ruleset#> .
@prefix spc:  <http://dkm.fbk.eu/springles/config#> .
@prefix :     <http://dkm.fbk.eu/springles/rdfs-ruleset#> .


spc:owl2rl-merged a spr:Ruleset ;
    rdfs:label "OWL2RL merged inference" ;
    spr:parameterizedBy
        [ spr:name "?constraints" ; spr:default "true"^^xsd:boolean ] ,
        [ spr:name "?inf_graph" ; spr:default "springles:inf"^^xsd:anyURI ] ;
    spr:prologue """
        PREFIX rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        PREFIX xsd:  <http://www.w3.org/2001/XMLSchema#>
        PREFIX owl:  <http://www.w3.org/2002/07/owl#>
        PREFIX sys:  <sys:> """ ;
    spr:closurePlan :plan ;
    spr:macro
        """ URI(x1) =
              iri(concat('sys:', md5(str(#x1)))) """ ,
        """ BNODE(x1) =
              bnode(str(#x1)) """ ,
        """ BNODE(x1, x2) =
              bnode(concat(str(#x1), str(#x2))) """ ,
        """ BNODE(x1, x2, x3) =
              bnode(concat(str(#x1), str(#x2), str(#x3))) """ ,
        """ BNODE(x1, x2, x3, x4) =
              bnode(concat(str(#x1), str(#x2), str(#x3), str(#x4))) """ ,
        """ BNODE(x1, x2, x3, x4, x5) =
              bnode(concat(str(#x1), str(#x2), str(#x3), str(#x4), str(#x5)))
        """ .

:plan spr:bind "?g = ?inf_graph"; spr:sequenceOf (
    [ spr:evalOf ( :owl_axioms ) ]
    [ spr:fixPointOf [ spr:evalOf (
        :eq-ref-s :eq-ref-p :eq-ref-o :eq-sym :eq-trans :eq-rep-s :eq-rep-p 
        :eq-rep-o :cax-sco :scm-sco :scm-eqc1 :scm-eqc2 :cls-nothing2 :prp-spo1 
        :scm-op :scm-dp :scm-spo :scm-eqp1 :scm-eqp2 :prp-dom :scm-dom1
        :scm-dom2 :prp-rng :scm-rng1 :scm-rng2 :prp-fp :prp-ifp :prp-symp
        :prp-trp :prp-spo2-1 :prp-spo2-2ax :prp-spo2-2 :prp-spo2-nax :prp-inv1 
        :prp-inv2 :prp-key-1ax :prp-key-2ax :prp-key-nax :prp-key-1 :prp-key-2 
        :prp-key-ns :prp-key-nr :prp-key-ne :cls-int-eq :cls-int-tbox
        :cls-int-abox :cls-uni-s :cls-uni-r :cls-svf1-o :cls-svf1-d :cls-svf2 
        :scm-svf1 :scm-svf2 :cls-avf :scm-avf1 :scm-avf2 :cls-hv1 :cls-hv2 
        :scm-hv :cls-maxc2 :cls-maxqc3 :cls-maxqc4 :cls-oo-s :cls-oo-r ) ] ]
    [ spr:fixPointOf [ spr:evalOf (
        :eq-diff23-axs1 :eq-diff23-axs2 :eq-diff23-axr
        :cax-adc-axs :cax-adc-axr
        :prp-adp-axs :prp-adp-axr ) ] ]
    [ spr:evalOf (
        :eq-diff1 :eq-diff23 :cax-dw :cax-adc
        :prp-asyp :prp-irp :prp-pdw :prp-adp :prp-npa1 :prp-npa2
        :cls-maxc1 :cls-maxqc1 :cls-maxqc2 :cls-com ) ] ) .

# General notes:
# - 85 rules (21 for constraints and related auxiliary rules)
# - datatype rules not implemented: dt-type2, dt-eq, dt-diff, dt-not-type


################################################################################
##                               AXIOMATIC  TRIPLES                           ##
################################################################################


# AXIOMATIC TRIPLES
#
# rules:   cls-thing, cls-nothing1, prp-ap, dt-type1
# notes:   A single axiom rule merging the original axioms has been implemented.

:owl_axioms a spr:Rule ;
    spr:head """ GRAPH ?g {
                   owl:Thing rdf:type owl:Class }
                 GRAPH ?g {
                   owl:Nothing rdf:type owl:Class }
                 GRAPH ?g {
                   rdfs:label rdf:type owl:AnnotationProperty.
                   rdfs:comment rdf:type owl:AnnotationProperty.
                   rdfs:seeAlso rdf:type owl:AnnotationProperty.
                   rdfs:isDefinedBy rdf:type owl:AnnotationProperty.
                   owl:deprecated rdf:type owl:AnnotationProperty.
                   owl:versionInfo rdf:type owl:AnnotationProperty.
                   owl:priorVersion rdf:type owl:AnnotationProperty.
                   owl:backwardCompatibleWith rdf:type owl:AnnotationProperty.
                   owl:incompatibleWith rdf:type owl:AnnotationProperty } 
                 GRAPH ?g {
                   rdf:PlainLiteral rdf:type rdfs:Datatype.
                   rdf:XMLLiteral rdf:type rdfs:Datatype.
                   rdfs:Literal rdf:type rdfs:Datatype.
                   xsd:decimal rdf:type rdfs:Datatype.
                   xsd:integer rdf:type rdfs:Datatype.
                   xsd:nonNegativeInteger rdf:type rdfs:Datatype.
                   xsd:nonPositiveInteger rdf:type rdfs:Datatype.
                   xsd:positiveInteger rdf:type rdfs:Datatype.
                   xsd:negativeInteger rdf:type rdfs:Datatype.
                   xsd:long rdf:type rdfs:Datatype.
                   xsd:int rdf:type rdfs:Datatype.
                   xsd:short rdf:type rdfs:Datatype.
                   xsd:byte rdf:type rdfs:Datatype.
                   xsd:unsignedLong rdf:type rdfs:Datatype.
                   xsd:unsignedInt rdf:type rdfs:Datatype.
                   xsd:unsignedShort rdf:type rdfs:Datatype.
                   xsd:unsignedByte rdf:type rdfs:Datatype.
                   xsd:float rdf:type rdfs:Datatype.
                   xsd:double rdf:type rdfs:Datatype.
                   xsd:string rdf:type rdfs:Datatype.
                   xsd:normalizedString rdf:type rdfs:Datatype.
                   xsd:token rdf:type rdfs:Datatype.
                   xsd:language rdf:type rdfs:Datatype.
                   xsd:Name rdf:type rdfs:Datatype.
                   xsd:NCName rdf:type rdfs:Datatype.
                   xsd:NMTOKEN rdf:type rdfs:Datatype.
                   xsd:boolean rdf:type rdfs:Datatype.
                   xsd:hexBinary rdf:type rdfs:Datatype.
                   xsd:base64Binary rdf:type rdfs:Datatype.
                   xsd:anyURI rdf:type rdfs:Datatype.
                   xsd:dateTime rdf:type rdfs:Datatype.
                   xsd:dateTimeStamp rdf:type rdfs:Datatype } """ ;
    spr:body """ """ .



################################################################################
##                                    AXIOMS                                  ##
################################################################################


# EQUALITY
#
# syntax:  ?x owl:sameAs ?y -- equality
# rules:   eq-ref, eq-sym, eq-trans, eq-rep-s, eq-rep-p, eq-rep-o
# notes:   Rule eq-ref split into eq-ref-s (subject), eq-ref-p (property),
#          eq-ref-o (object).

:eq-ref-s a spr:Rule ;
    spr:head """ GRAPH ?g { ?s owl:sameAs ?s } """ ;
    spr:body """ ?s ?p ?o
                 FILTER NOT EXISTS { ?s owl:sameAs ?s } """ .

:eq-ref-p a spr:Rule ;
    spr:head """ GRAPH ?g { ?p owl:sameAs ?p } """ ;
    spr:body """ ?s ?p ?o
                 FILTER (?p != owl:sameAs)
                 FILTER NOT EXISTS { ?p owl:sameAs ?p } """ .

:eq-ref-o a spr:Rule ;
    spr:head """ GRAPH ?g { ?o owl:sameAs ?o } """ ;
    spr:body """ ?s ?p ?o
                 FILTER NOT EXISTS { ?o owl:sameAs ?o } """ .

:eq-sym a spr:Rule ;
    spr:head """ GRAPH ?g { ?y owl:sameAs ?x } """ ;
    spr:body """ ?x owl:sameAs ?y
                 FILTER (?x != ?y)
                 FILTER NOT EXISTS { ?y owl:sameAs ?x } """ .

:eq-trans a spr:Rule ;
    spr:head """ GRAPH ?g { ?x owl:sameAs ?z } """ ;
    spr:body """ ?x owl:sameAs ?y.  ?y owl:sameAs ?z
                 FILTER (?x != ?y && ?y != ?z && ?x != ?z)
                 FILTER NOT EXISTS { ?x owl:sameAs ?z } """ .

:eq-rep-s a spr:Rule ;
    spr:head """ GRAPH ?g { ?s2 ?p ?o } """ ;
    spr:body """ ?s1 ?p ?o.  ?s1 owl:sameAs ?s2
                 FILTER (?s1 != ?s2)
                 FILTER NOT EXISTS { ?s2 ?p ?o } """ .

:eq-rep-p a spr:Rule ;
    spr:head """ GRAPH ?g { ?s ?p2 ?o } """ ;
    spr:body """ ?s ?p1 ?o.  ?p1 owl:sameAs ?p2
                 FILTER (?p1 != ?p2)
                 FILTER NOT EXISTS { ?s ?p2 ?o } """ .

:eq-rep-o a spr:Rule ;
    spr:head """ GRAPH ?g { ?s ?p ?o2 } """ ;
    spr:body """ ?s ?p ?o1.  ?o1 owl:sameAs ?o2
                 FILTER (?o1 != ?o2)
                 FILTER NOT EXISTS { ?s ?p ?o2 } """ .


# INEQUALITY
#
# syntax:  ?i1 owl:differentFrom ?i2.
#          ?a rdf:type owl:AllDifferent; owl:members ( ?i1 ... ?iN ).
#          ?a rdf:type owl:AllDifferent; owl:distinctMembers ( ?i1 ... ?iN ).
# rules:   eq-diff1, eq-diff2, eq-diff3
# notes:   Rules eq-diff2 and eq-diff3 are implemented by eq-diff23 after
#          recursively preprocessing the individual list via auxiliary rules
#          eq-diff23-axs1, eq-diff23-axs2 (start) and eq-diff23-axr (recursion).

:eq-diff1 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:differentFrom violated';
                               rdfs:seeAlso ?i1, ?i2 } """ ;
    spr:body """ ?i1 owl:sameAs ?i2; owl:differentFrom ?i2
                 BIND (#BNODE(owl:differentFrom, ?i1, ?i2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency }
                 FILTER (str(?i1) < str(?i2)) """ .

:eq-diff23-axs1 a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:distinctMember ?i1, ?i2;
                               sys:expandAllDifferent ?l3 } """ ;
    spr:body """ ?x rdf:type owl:AllDifferent; owl:members ?l1.
                 ?l1 rdf:first ?i1; rdf:rest ?l2.
                 ?l2 rdf:first ?i2; rdf:rest ?l3
                 FILTER NOT EXISTS { ?x sys:expandAllDifferent ?l3 }
                 BIND (!EXISTS { ?x sys:distinctMember ?i1 } AS ?_emit1)
                 BIND (!EXISTS { ?x sys:distinctMember ?i2 } AS ?_emit2) """ .

:eq-diff23-axs2 a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:distinctMember ?i1, ?i2;
                               sys:expandAllDifferent ?l3 } """ ;
    spr:body """ ?x rdf:type owl:AllDifferent; owl:distinctMembers ?l1.
                 ?l1 rdf:first ?i1; rdf:rest ?l2.
                 ?l2 rdf:first ?i2; rdf:rest ?l3
                 FILTER NOT EXISTS { ?x sys:expandAllDifferent ?l3 }
                 BIND (!EXISTS { ?x sys:distinctMember ?i1 } AS ?_emit1)
                 BIND (!EXISTS { ?x sys:distinctMember ?i2 } AS ?_emit2) """ .

:eq-diff23-axr a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:distinctMember ?i1;
                               sys:expandAllDifferent ?l2 } """ ;
    spr:body """ ?x sys:expandAllDifferent ?l1.
                 ?l1 rdf:first ?i1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?x sys:expandAllDifferent ?l2 }
                 BIND (!EXISTS { ?x sys:distinctMember ?i1 } AS ?_emit1) """ .

:eq-diff23 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:AllDifferent violated';
                               rdfs:seeAlso ?i1, ?i2 } """ ;
    spr:body """ ?x sys:distinctMember ?i1, ?i2.  ?i1 owl:sameAs ?i2
                 FILTER (?i1 != ?i2)
                 BIND (#BNODE(owl:AllDifferent, ?i1, ?i2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency }
                 FILTER (str(?i1) <= str(?i2)) """ .


# SUBCLASS AND EQUIVALENT CLASS
#
# syntax:  ?c1 rdfs:subClassOf ?c2 -- subclass
#          ?c1 owl:equivalentClass ?c2 -- class equivalence
# rules:   cax-sco, scm-cls, scm-sco, scm-eqc1, scm-eqc2, cls-nothing2
#          cax-eqc1, cax-eqc2
# notes:   Rules cax-eqc1 and cax-eqc2 are redundant, as they are implemented
#          by cax-sco and scm-eqc2 (via rdfs:subClassOf semantics).

:cax-sco a spr:Rule ;
    spr:head """ GRAPH ?g { ?x rdf:type ?c2 } """ ;
    spr:body """ ?x rdf:type ?c1 .  ?c1 rdfs:subClassOf ?c2
                 FILTER (?c1 != ?c2)
                 FILTER NOT EXISTS { ?x rdf:type ?c2 } """ .

:scm-sco a spr:Rule ; 
    spr:head """ GRAPH ?g { ?c1 rdfs:subClassOf ?c3 } """ ;
    spr:body """ ?c1 rdfs:subClassOf ?c2.  ?c2 rdfs:subClassOf ?c3
                 FILTER (?c1 != ?c2 && ?c2 != ?c3 && ?c1 != ?c3)
                 FILTER NOT EXISTS { ?c1 rdfs:subClassOf ?c3 } """ .

:scm-eqc1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?c1 owl:equivalentClass ?c2 } """ ;
    spr:body """ ?c1 rdfs:subClassOf ?c2.  ?c2 rdfs:subClassOf ?c1
                 FILTER (?c1 != ?c2)
                 FILTER NOT EXISTS { ?c1 owl:equivalentClass ?c2 } """ .

:scm-eqc2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?c1 rdfs:subClassOf ?c2 .
                            ?c2 rdfs:subClassOf ?c1 } """ ;
    spr:body """ ?c1 owl:equivalentClass ?c2
                 FILTER (?c1 != ?c2)
                 BIND (!EXISTS { ?c1 rdfs:subClassOf ?c2 } AS ?_emit1)
                 BIND (!EXISTS { ?c2 rdfs:subClassOf ?c1 } AS ?_emit2) """ .

:cls-nothing2 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:Nothing violated';
                               rdfs:seeAlso ?x } """ ;
    spr:body """ ?x rdf:type owl:Nothing
                 BIND (#BNODE(owl:Nothing, ?x) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .
    

# CLASS DISJOINTNESS
#
# syntax:  ?c1 owl:disjointWith ?c2
# rules:   cax-dw, cax-adc
# notes:   Rule cax-adc requires recursive expansion of class list through
#          auxiliary rules cax-adc-axs (start) and cax-adc-axr (recursion).

:cax-dw a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:disjointWith violated';
                               rdfs:seeAlso ?x, ?c1, ?c2 } """ ;
    spr:body """ ?c1 owl:disjointWith ?c2.  ?x a ?c1, ?c2
                 BIND (#BNODE(owl:disjointWith, ?x, ?c1, ?c2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .
    
:cax-adc-axs a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:disjointClass ?c1, ?c2;
                               sys:expandAllDisjointClasses ?l3 } """ ;
    spr:body """ ?x rdf:type owl:AllDisjointClasses; owl:members ?l1.
                 ?l1 rdf:first ?c1; rdf:rest ?l2.
                 ?l2 rdf:first ?c2; rdf:rest ?l3
                 FILTER NOT EXISTS { ?x sys:expandAllDisjointClasses ?l3 }
                 BIND (!EXISTS { ?x sys:disjointClass ?c1 } AS ?_emit1)
                 BIND (!EXISTS { ?x sys:disjointClass ?c2 } AS ?_emit2) """ .

:cax-adc-axr a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:disjointClass ?c1;
                               sys:expandAllDisjointClasses ?l2 } """ ;
    spr:body """ ?x sys:expandAllDisjointClasses ?l1.
                 ?l1 rdf:first ?c1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?x sys:expandAllDisjointClasses ?l2 }
                 BIND (!EXISTS { ?x sys:disjointClass ?c1 } AS ?_emit1) """ .
                            
:cax-adc a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:AllDisjointClasses violated';
                               rdfs:seeAlso ?x, ?c1, ?c2 } """ ;
    spr:body """ ?x sys:disjointClass ?c1, ?c2.  ?x a ?c1, ?c2
                 FILTER (?c1 != ?c2)
                 BIND (#BNODE(owl:AllDisjointClasses, ?x, ?c1, ?c2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency }
                 FILTER (str(?c1) < str(?c2)) """ .


# SUBPROPERTY AND EQUIVALENT PROPERTIES
#
# syntax:  ?p1 rdfs:subPropertyOf ?p2 -- subproperty
#          ?p1 owl:equivalentProperty ?p2 -- property equivalence
# axioms:  prp-spo1, scm-op, scm-dp, scm-spo, scm-eqp1, scm-eqp2,
#          prp-eqp1, prp-eqp2
# notes:   Rules prp-eqp1 and prp-eqp2 are redundant, as already implemented by
#          scm-eqp1 and prp-spo1 (rdfs:subPropertyOf semantics).

:prp-spo1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?x ?p2 ?y } """ ;
    spr:body """ ?x ?p1 ?y.  ?p1 rdfs:subPropertyOf ?p2
                 FILTER (?p1 != ?p2)
                 FILTER NOT EXISTS { ?x ?p2 ?y } """ .

:scm-op a spr:Rule ;
    spr:head """ GRAPH ?g { ?p rdfs:subPropertyOf ?p;
                               owl:equivalentProperty ?p } """ ;
    spr:body """ ?p rdf:type owl:ObjectProperty
                 BIND (!EXISTS { ?p rdfs:subPropertyOf ?p } AS ?_emit1) 
                 BIND (!EXISTS { ?p owl:equivalentProperty ?p } AS ?_emit2)
                 """ .
            
:scm-dp a spr:Rule ;
    spr:head """ GRAPH ?g { ?p rdfs:subPropertyOf ?p;
                               owl:equivalentProperty ?p } """ ;
    spr:body """ ?p rdf:type owl:DatatypeProperty
                 BIND (!EXISTS { ?p rdfs:subPropertyOf ?p } AS ?_emit1)
                 BIND (!EXISTS { ?p owl:equivalentProperty ?p } AS ?_emit2)
                 """ .
            
:scm-spo a spr:Ruel ;
    spr:head """ GRAPH ?g { ?p1 rdfs:subPropertyOf ?p3 } """ ;
    spr:body """ ?p1 rdfs:subPropertyOf ?p2.  ?p2 rdfs:subPropertyOf ?p3 
                 FILTER (?p1 != ?p2 && ?p2 != ?p3 && ?p1 != ?p3)
                 FILTER NOT EXISTS { ?p1 rdfs:subPropertyOf ?p3 } """ .

:scm-eqp1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p1 rdfs:subPropertyOf ?p2.
                            ?p2 rdfs:subPropertyOf ?p1 } """ ;
    spr:body """ ?p1 owl:equivalentProperty ?p2
                 FILTER (?p1 != ?p2)
                 BIND (!EXISTS { ?p1 rdfs:subPropertyOf ?p2 } AS ?_emit1)
                 BIND (!EXISTS { ?p2 rdfs:subPropertyOf ?p1 } AS ?_emit2) """ .

:scm-eqp2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p1 owl:equivalentProperty ?p2 } """ ;
    spr:body """ ?p1 rdfs:subPropertyOf ?p2.  ?p2 rdfs:subPropertyOf ?p1
                 FILTER (?p1 != ?p2)
                 FILTER NOT EXISTS { ?p1 owl:equivalentProperty ?p2 } """ .


# PROPERTY DOMAIN
#
# syntax:  ?p rdfs:domain ?t
# rules:   prp-dom, scm-dom1, scm-dom2

:prp-dom a spr:Rule ;
    spr:head """ GRAPH ?g { ?x rdf:type ?c } """ ;
    spr:body """ ?x ?p ?y.  ?p rdfs:domain ?c
                 FILTER NOT EXISTS { ?x rdf:type ?c } """ .

:scm-dom1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p rdfs:domain ?c2 } """ ;
    spr:body """ ?p rdfs:domain ?c1.  ?c1 rdfs:subClassOf ?c2
                 FILTER (?c1 != ?c2)
                 FILTER NOT EXISTS { ?p rdfs:domain ?c2 } """ .

:scm-dom2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p1 rdfs:domain ?c } """ ;
    spr:body """ ?p1 rdfs:subPropertyOf ?p2.  ?p2 rdfs:domain ?c
                 FILTER (?p1 != ?p2)
                 FILTER NOT EXISTS { ?p1 rdfs:domain ?c } """ .


# PROPERTY RANGE
#
# syntax:  ?p rdfs:range ?t
# rules:   prp-rng, scm-rng1, scm-rng2
# issues:  For datatype properties, prp-rng must be implemented as a constraint
#          checking that the literal value belong to the value space of ?t
#          (dt-not-type)

:prp-rng a spr:Rule ;
    spr:head """ GRAPH ?g { ?y rdf:type ?c } """ ;
    spr:body """ ?x ?p ?y.  ?p rdfs:range ?c
                 FILTER NOT EXISTS { ?y rdf:type ?c } """ .
    
:scm-rng1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p rdfs:range ?c2 } """ ;
    spr:body """ ?p rdfs:range ?c1.  ?c1 rdfs:subClassOf ?c2
                 FILTER (?c1 != ?c2)
                 FILTER NOT EXISTS { ?p rdfs:range ?c2 } """ .

:scm-rng2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p1 rdfs:range ?c } """ ;
    spr:body """ ?p1 rdfs:subPropertyOf ?p2.  ?p2 rdfs:range ?c
                 FILTER (?p1 != ?p2)
                 FILTER NOT EXISTS { ?p1 rdfs:range ?c } """ .


# FUNCTIONAL PROPERTY
#
# syntax:  ?p rdf:type owl:FunctionalProperty
# rules:   prp-fp
# issues:  For datatype properties, rule prp-fp should be implemented as a
#          constraint checking that the two literal denote the same value
#          (dt-diff)

:prp-fp a spr:Rule ;
    spr:head """ GRAPH ?g { ?y1 owl:sameAs ?y2 } """ ;
    spr:body """ ?p rdf:type owl:FunctionalProperty.  ?x ?p ?y1, ?y2
                 FILTER (?y1 != ?y2)
                 FILTER NOT EXISTS { ?y1 owl:sameAs ?y2 } """ .


# INVERSE FUNCTIONAL PROPERTY
#
# syntax:  ?p rdf:type owl:InverseFunctionalProperty
# rules:   prp-ifp

:prp-ifp a spr:Rule ;
    spr:head """ GRAPH ?g { ?x1 owl:sameAs ?x2 } """ ;
    spr:body """ ?p rdf:type owl:InverseFunctionalProperty.
                 ?x1 ?p ?y.  ?x2 ?p ?y
                 FILTER (?x1 != ?x2)
                 FILTER NOT EXISTS { ?x1 owl:sameAs ?x2 } """ .


# SYMMETRIC PROPERTY
#
# syntax:  ?p rdf:type owl:SymmetricProperty
# rules:   prp-symp

:prp-symp a spr:Rule ;
    spr:head """ GRAPH ?g { ?y ?p ?x } """ ;
    spr:body """ ?p rdf:type owl:SymmetricProperty.  ?x ?p ?y
                 FILTER NOT EXISTS { ?y ?p ?x } """ .


# ASYMMETRIC PROPERTY
#
# syntax:  ?p rdf:type owl:AsymmetricProperty
# rules:   prp-asyp

:prp-asyp a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:AsymmetricProperty violated';
                               rdfs:seeAlso ?x, ?y, ?p } """ ;
    spr:body """ ?p rdf:type owl:AsymmetricProperty.  ?x ?p ?y.  ?y ?p ?x
                 BIND (#BNODE(owl:AsymmetricProperty, ?x, ?y, ?p) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency }
                 FILTER (str(?x) < str(?y)) """ .


# IRREFLEXIVE PROPERTY
#
# syntax:  ?p rdf:type owl:IrreflexiveProperty
# rules:   prp-irp

:prp-irp a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:IrreflexiveProperty violated';
                               rdfs:seeAlso ?x, ?p } """ ;
    spr:body """ ?p rdf:type owl:IrreflexiveProperty.  ?x ?p ?x
                 BIND (#BNODE(owl:IrreflexiveProperty, ?x, ?p) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .


# TRANSITIVE PROPERTY
#
# syntax:  ?p rdf:type owl:TransitiveProperty
# rules:   prp-trp

:prp-trp a spr:Rule ; 
    spr:head """ GRAPH ?g { ?x ?p ?z } """ ;
    spr:body """ ?p rdf:type owl:TransitiveProperty.  ?x ?p ?y.  ?y ?p ?z
                 FILTER (?x != ?y && ?y != ?z)
                 FILTER NOT EXISTS { ?x ?p ?z } """ .


# PROPERTY CHAIN
#
# syntax:  ?p owl:propertyChainAxiom ( ?p1 ... ?pN )
# rules:   prp-spo2
# notes:   Chains of length 1 are handled by prp-spo2-1 via introduction of
#          rdfs:subPropertyOf axiom. Chains of length 2 are handled by
#          preprocessing the axiom via prp-spo2-2ax and then applying prp-spo2-2
#          to the ABox. Chains of lenght >= 3 are reduced to composition of
#          chains of length <= 2 by creating additional properties, i.e.,
#          transforming to:
#            ?p owl:propertyChainAxiom ( ?p1 ?l1 )
#            ?l1 owl:propertyChainAxiom ( ?p2 ?l2 ) ...
#            ... ?lN-1 owl:propertyChainAxiom ( ?pN-1 ?pN ) -- prp-spo-2ax, OR
#            ... ?pN rdfs:subPropertyOf ?lN -- prp-spo2-1

:prp-spo2-1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?p1 rdfs:subPropertyOf ?p } """ ;
    spr:body """ ?p owl:propertyChainAxiom ?l.
                 ?l rdf:first ?p1; rdf:rest rdf:nil
                 FILTER NOT EXISTS { ?p1 rdfs:subPropertyOf ?p } """ .

:prp-spo2-2ax a spr:Rule ;
    spr:head """ GRAPH ?g { ?l1 sys:chain2prop1 ?p1; 
                                sys:chain2prop2 ?p2 } """ ;
    spr:body """ ?p owl:propertyChainAxiom ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2.
                 ?l2 rdf:first ?p2; rdf:rest rdf:nil
                 FILTER NOT EXISTS { ?l1 sys:chain2prop1 ?p1 } """ .

:prp-spo2-2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?x ?p ?z } """ ;
    spr:body """ ?p owl:propertyChainAxiom ?l.
                 ?l sys:chain2prop1 ?p1; sys:chain2prop2 ?p2.
                 ?x ?p1 ?y.  ?y ?p2 ?z
                 FILTER NOT EXISTS { ?x ?p ?z } """ .

:prp-spo2-nax a spr:Rule ;
    spr:head """ GRAPH ?g { ?l1 sys:chain2prop1 ?p1; sys:chain2prop2 ?u.
                            ?u owl:propertyChainAxiom ?l2 } """ ;
    spr:body """ ?p owl:propertyChainAxiom ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2.
                 ?l2 rdf:rest ?l3
                 FILTER (?l3 != rdf:nil)
                 BIND (#URI(?l2) AS ?u)
                 FILTER NOT EXISTS { ?u owl:propertyChainAxiom ?l2 } """ .


# INVERSE PROPERTY
#
# syntax:  ?p1 owl:inverseOf ?p2
# rules:   prp-inv1, prp-inv2

:prp-inv1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?y ?p2 ?x } """ ;
    spr:body """ ?p1 owl:inverseOf ?p2.  ?x ?p1 ?y
                 FILTER NOT EXISTS { ?y ?p2 ?x } """ .

:prp-inv2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?y ?p1 ?x } """ ;
    spr:body """ ?p1 owl:inverseOf ?p2.  ?x ?p2 ?y
                 FILTER NOT EXISTS { ?y ?p1 ?x } """ .


# PROPERTY DISJOINTNESS
#
# syntax:  ?p1 owl:propertyDisjointWith ?p2.
#          ?a rdf:type owl:AllDisjointProperties; owl:members ( ?p1 ... ?pN ).
# rules:   prp-pdw, prp-adp
# notes:   Rule prp-adp requires expanding recursively the property list through
#          auxiliary rules prp-adp-axs (start) and prp-adp-axr (recursion).

:prp-pdw a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:propertyDisjointWith violated';
                               rdfs:seeAlso ?x, ?y, ?p1, ?p2 } """ ;
    spr:body """ ?p1 owl:propertyDisjointWith ?p2.  ?x ?p1 ?y; ?p2 ?y
                 BIND (#BNODE(owl:propertyDisjointWith, ?x, ?y, ?p1, ?p2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .

:prp-adp-axs a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:disjointProperty ?p1, ?p2;
                               sys:expandAllDisjointProperties ?l3 } """ ;
    spr:body """ ?x rdf:type owl:AllDisjointProperties; owl:members ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2.
                 ?l2 rdf:first ?p2; rdf:rest ?l3
                 FILTER NOT EXISTS { ?x sys:expandAllDisjointProperties ?l3 }
                 BIND (!EXISTS { ?x sys:disjointProperty ?p1 } AS ?_emit1)
                 BIND (!EXISTS { ?x sys:disjointProperty ?p2 } AS ?_emit2) """ .

:prp-adp-axr a spr:Rule ; # constraint, auxiliary
    spr:head """ GRAPH ?g { ?x sys:disjointProperty ?p1;
                               sys:expandAllDisjointProperties ?l2 } """ ;
    spr:body """ ?x sys:expandAllDisjointProperties ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?x sys:expandAllDisjointProperties ?l2 }
                 BIND (!EXISTS { ?x sys:disjointProperty ?p1 } AS ?_emit1) """ .

:prp-adp a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:AllDisjointProperties violated';
                               rdfs:seeAlso ?x, ?y, ?p1, ?p2 } """ ;
    spr:body """ ?x sys:disjointProperty ?p1, ?p2.  ?x ?p1 ?y; ?p2 ?y
                 FILTER (?p1 != ?p2)
                 BIND (#BNODE(owl:AllDisjointProperties,
                              ?x, ?y, ?p1, ?p2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency }
                 FILTER (str(?p1) < str(?p2)) """ .


# KEY
#
# syntax:  ?c owl:hasKey ( ?p1 ... ?pN )
# rules:   prp-key
# notes:   Common cases with keys of length 1 and 2 handled separately by rules
#          prp-key-1ax, prp-key-1 (length 1); prp-key-2ax, prp-key-2 (length 2).
#          Keys with length >= 3 handled by auxiliary rule prp-key-nax and rules
#          prp-key-ns (start), prp-key-nr (recursion), prp-key-ne (end).

:prp-key-1ax a spr:Rule ;
    spr:head """ GRAPH ?g { ?c sys:key1prop ?p } """ ;
    spr:body """ ?c owl:hasKey [ rdf:first ?p; rdf:rest rdf:nil ]
                 FILTER NOT EXISTS { ?c sys:key1prop ?p } """ .

:prp-key-2ax a spr:Rule ;
    spr:head """ GRAPH ?g { ?l sys:key2prop1 ?p1; sys:key2prop2 ?p2 } """ ;
    spr:body """ ?c owl:hasKey ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2.
                 ?l2 rdf:first ?p2; rdf:rest rdf:nil
                 FILTER NOT EXISTS { ?l sys:key2prop1 ?p1 } """ .

:prp-key-nax a spr:Rule ;
    spr:head """ GRAPH ?g { ?l1 sys:keyNprop1 ?p1; sys:keyNprop2 ?p2;
                                sys:keyNprop3 ?p3; sys:keyNrest ?l } """ ;
    spr:body """ ?c owl:hasKey ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2.
                 ?l2 rdf:first ?p2; rdf:rest ?l3.
                 ?l3 rdf:first ?p3; rdf:rest ?l
                 FILTER NOT EXISTS { ?l1 sys:keyNrest ?l } """ .

:prp-key-1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?x owl:sameAs ?y } """ ;
    spr:body """ ?c sys:key1prop ?p.
                 ?x rdf:type ?c; ?p ?v.
                 ?y rdf:type ?c; ?p ?v 
                 FILTER (?x != ?y)
                 FILTER NOT EXISTS { ?x owl:sameAs ?y } """ .

:prp-key-2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?x owl:sameAs ?y } """ ;
    spr:body """ ?c owl:hasKey ?l.
                 ?l sys:key2prop1 ?p1; sys:key2prop2 ?p2.
                 ?x rdf:type ?c; ?p1 ?v1; ?p2 ?v2.
                 ?y rdf:type ?c; ?p1 ?v1; ?p2 ?v2
                 FILTER (?x != ?y)
                 FILTER NOT EXISTS { ?x owl:sameAs ?y } """ .

:prp-key-ns a spr:Rule ;
    spr:head """ GRAPH ?g { ?b sys:keyNarg1 ?x; sys:keyNarg2 ?y ;
                               sys:keyNnode ?l } """ ;
    spr:body """ ?c owl:hasKey ?l1.
                 ?l1 sys:keyNprop1 ?p1; sys:keyNprop2 ?p2;
                     sys:keyNprop3 ?p3; sys:keyNrest ?l.
                 ?x rdf:type ?c; ?p1 ?v1; ?p2 ?v2; ?p3 ?v3. 
                 ?y rdf:type ?c; ?p1 ?v1; ?p2 ?v2; ?p3 ?v3
                 FILTER (?x != ?y && str(?x) <= str(?y))
                 BIND (#BNODE(?x, ?y, ?l1) AS ?b)
                 FILTER NOT EXISTS { ?b sys:keyNnode ?l } """ .

:prp-key-nr a spr:Rule ;
    spr:head """ GRAPH ?g { ?b sys:keyNnode ?l2 } """ ;
    spr:body """ ?b sys:keyNarg1 ?x; sys:keyNarg2 ?y; sys:keyNnode ?l1.
                 ?l1 rdf:first ?p1; rdf:rest ?l2.  ?x ?p1 ?v.  ?y ?p2 ?v
                 FILTER NOT EXISTS { ?b sys:keyNnode ?l2 } """ .

:prp-key-ne a spr:Rule ;
    spr:head """ GRAPH ?g { ?x owl:sameAs ?y } """ ;
    spr:body """ ?b sys:keyNarg1 ?x; sys:keyNarg2 ?y; sys:keyNnode rdf:nil
                 FILTER NOT EXISTS { ?x owl:sameAs ?y } """ .


# NEGATIVE PROPERTY ASSERTIONS
#
# syntax:  ?x rdf:type owl:NegativePropertyAssertion;
#             owl:sourceIndividual ?s;
#             owl:assertionProperty ?p;
#             owl:targetIndividual ?o; -- for object properties, OR
#             owl:targetValue ?v; -- for datatype properties
# rules:   prp-npa1, prp-npa2

:prp-npa1 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:seeAlso ?s, ?p, ?o ;
                               rdfs:label
                                  'owl:NegativePropertyAssertion violated'
                          } """ ;
    spr:body """ ?x owl:sourceIndividual ?s;
                    owl:assertionProperty ?p;
                    owl:targetIndividual ?o.
                 ?s ?p ?o
                 BIND (#BNODE(owl:NegativePropertyAssertion, ?s, ?p, ?o) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .

:prp-npa2 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:seeAlso ?s, ?p, ?v;
                               rdfs:label
                                  'owl:NegativePropertyAssertion violated'
                          } """ ;
    spr:body """ ?x owl:sourceIndividual ?s;
                    owl:assertionProperty ?p;
                    owl:targetValue ?v.
                 ?s ?p ?v
                 BIND (#BNODE(owl:NegativePropertyAssertion, ?s, ?p, ?v) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .


################################################################################
##                              CLASS EXPRESSIONS                             ##
################################################################################

# INTERSECTION
#
# syntax:  ?c owl:intersectionOf ( ?c1 ... ?cN )
# rules:   cls-int1, cls-int2
# notes:   Special case :c owl:intersectionOf ( :c1 ) implemented by cls-int-eq
#          by declaring :c and :c1 equivalent classes.
#          Case :c owl:intersectionOf ( :c1 :c2 :c3 ... :cN ) transformed by
#          rule cls-int-tbox into:
#            :c owl:intersectionOf ( :c1 :l1 ) ; rdfs:subClassOf :c1 , :l1 .
#            :l1 owl:intersectionOf ( :c2 :l2 ) ; rdfs:subClassOf :c2 , :l2 .
#            ... :lN owl:intersectionOf ( :cN )
#          last axiom is handled by cls-int-eq, while rule cls-int-tbox handles
#          intersections of length 2. Original rule cls-int2 is implemented
#          by introducing rdfs:subClassOf and owl:equivalentClass axioms.

:cls-int-eq a spr:Rule ;
    spr:head """ GRAPH ?g { ?c owl:equivalentClass ?c1 } """ ;
    spr:body """ ?c owl:intersectionOf ?l.  ?l rdf:first ?c1; rdf:rest rdf:nil
                 FILTER NOT EXISTS { ?c owl:equivalentClass ?c1 } """ .

:cls-int-tbox a spr:Rule ;
    spr:head """ GRAPH ?g { ?c sys:intersectionOfMember1 ?c1;
                               sys:intersectionOfMember2 ?l2;
                               rdfs:subClassOf ?c1, ?l2.
                            ?l2 owl:intersectionOf ?l2 } """ ;
    spr:body """ ?c owl:intersectionOf ?l1.
                 ?l1 rdf:first ?c1; rdf:rest ?l2
                 FILTER (?l1 != rdf:nil)
                 FILTER NOT EXISTS { ?l2 owl:intersectionOf ?l2 }
                 BIND (!EXISTS { ?c rdfs:subClassOf ?c1 } AS ?_emit3) """ .

:cls-int-abox a spr:Rule ;
    spr:head """ GRAPH ?g { ?x rdf:type ?c } """ ;
    spr:body """ ?c sys:intersectionOfMember1 ?c1; 
                    sys:intersectionOfMember2 ?c2.
                 ?x rdf:type ?c1, ?c2
                 FILTER NOT EXISTS { ?x rdf:type ?c } """ .


# UNION
#
# syntax:  ?c owl:unionOf ( ?c1 ... ?cN )
# rules:   cls-uni, scm-uni
# notes:   Rule cls-uni is redundant, as implemented by scm-uni and rules about
#          rdfs:subClassOf. Rule scm-uni is implemented by recursively
#          navigating the class list by rule cls-uni-s (start) and rule
#          cls-uni-r (recursion).

:cls-uni-s a spr:Rule ;
    spr:head """ GRAPH ?g { ?c sys:expandUnion ?l2.
                            ?c1 rdfs:subClassOf ?c } """ ;
    spr:body """ ?c owl:unionOf ?l1.
                 ?l1 rdf:first ?c1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?c sys:expandUnion ?l2 }
                 BIND (!EXISTS { ?c1 rdfs:subClassOf ?c } AS ?_emit2) """ .

:cls-uni-r a spr:Rule ;
    spr:head """ GRAPH ?g { ?c sys:expandUnion ?l2.
                            ?c1 rdfs:subClassOf ?c } """ ;
    spr:body """ ?c sys:expandUnion ?l1.  ?l1 rdf:first ?c1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?c sys:expandUnion ?l2 }
                 BIND (!EXISTS { ?c1 rdfs:subClassOf ?c } AS ?_emit2) """ .


# EXISTENTIAL QUANTIFICATION
#
# syntax:  ?r a owl:Restriction; owl:onProperty ?p; owl:someValuesFrom ?t
# rules:   cls-svf1, cls-svf2, scm-svf1, scm-svf2
# notes:   Rule cls-svf1 is split in cls-svf1-o and cls-svf1-d respectively for
#          object and datatype properties. Rule cls-svf2 is implemented
#          unchanged. Note that cls-svf1-d is restricted to a subset of OWL2RL
#          datatypes, i.e., it supports only axioms where :t is one of the
#          following:
#            rdfs:Literal, rdf:XMLLiteral, xsd:decimal, xsd:float, xsd:double,
#            rdf:PlainLiteral, rdf:langString, xsd:string, xsd:boolean,
#            xsd:hexBinary, xsd:base64Binary, xsd:anyURI, xsd:dateTime,
#            xsd:dateTimeStamp

:cls-svf1-o a spr:Rule ;
    spr:head """ GRAPH ?g { ?u rdf:type ?r } """ ;
    spr:body """ ?r owl:someValuesFrom ?c; owl:onProperty ?p. 
                 ?u ?p ?v.  ?v rdf:type ?c
                 FILTER NOT EXISTS { ?u rdf:type ?r } """ .

:cls-svf1-d a spr:Rule ;
    spr:head """ GRAPH ?g { ?u rdf:type ?r } """ ;
    spr:body """ ?r owl:someValuesFrom ?d; owl:onProperty ?p.  ?u ?p ?v
                 FILTER (isliteral(?v))
                 BIND (DATATYPE(?v) AS ?t)
                 FILTER (?d = rdfs:Literal ||
                         ?d = rdf:XMLLiteral && ?t = rdf:XMLLiteral ||
                         ?d = xsd:decimal && (
                              ?t = xsd:negativeInteger    || ?t = xsd:decimal ||
                              ?t = xsd:positiveInteger    || ?t = xsd:integer ||
                              ?t = xsd:nonNegativeInteger || ?t = xsd:long ||
                              ?t = xsd:nonPositiveInteger || ?t = xsd:int ||
                              ?t = xsd:unsignedLong       || ?t = xsd:short ||
                              ?t = xsd:unsignedInt        || ?t = xsd:byte ||
                              ?t = xsd:unsignedShort      || ?t = xsd:int ||
                              ?t = xsd:unsignedByte) ||
                         ?d = xsd:float && ?t = xsd:float ||
                         ?d = xsd:double && ?t = xsd:double ||
                         ?d = rdf:PlainLiteral && (
                              ?t = rdf:PlainLiteral     || ?t = xsd:language ||
                              ?t = xsd:string           || ?t = xsd:Name ||
                              ?t = rdf:langString       || ?t = xsd:NCName ||
                              ?t = xsd:normalizedString || ?t = xsd:NMTOKEN ||
                              ?t = xsd:token) ||
                         ?d = rdf:langString && ?t = rdf:langString ||
                         ?d = xsd:string && (
                              ?t = xsd:string           || ?t = xsd:Name ||
                              ?t = xsd:normalizedString || ?t = xsd:NCName ||
                              ?t = xsd:token            ||  ?t = xsd:NMTOKEN ||
                              ?t = xsd:language) ||
                         ?d = xsd:boolean && ?t = xsd:boolean ||
                         ?d = xsd:hexBinary && ?t = xsd:hexBinary ||
                         ?d = xsd:base64Binary && ?t = xsd:base64Binary ||
                         ?d = xsd:anyURI && ?t = xsd:anyURI ||
                         ?d = xsd:dateTime && ?t = xsd:dateTime ||
                         ?d = xsd:dateTimeStamp && ?t = xsd:dateTimeStamp)
                 FILTER NOT EXISTS { ?u rdf:type ?r } """ .

:cls-svf2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?u rdf:type ?r } """ ;
    spr:body """ ?r owl:someValuesFrom owl:Thing; owl:onProperty ?p.
                 ?u ?p ?v
                 FILTER NOT EXISTS { ?u rdf:type ?r } """ .

:scm-svf1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?r1 rdfs:subClassOf ?r2 } """ ;
    spr:body """ ?r1 owl:someValuesFrom ?t1; owl:onProperty ?p.
                 ?r2 owl:someValuesFrom ?t2; owl:onProperty ?p.
                 ?t1 rdfs:subClassOf ?t1
                 FILTER (?r1 != ?r2)
                 FILTER NOT EXISTS { ?r1 rdfs:subClassOf ?r2 } """ .

:scm-svf2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?r1 rdfs:subClassOf ?r2 } """ ;
    spr:body """ ?r1 owl:someValuesFrom ?t; owl:onProperty ?p1.
                 ?r2 owl:someValuesFrom ?t; owl:onProperty ?p2.
                 ?p1 rdfs:subPropertyOf ?p2
                 FILTER (?r1 != ?r2)
                 FILTER NOT EXISTS { ?r1 rdfs:subClassOf ?r2 } """ .


# UNIVERSAL QUANTIFICATION
#
# syntax:  ?r rdf:type owl:Restriction; owl:allValuesFrom ?t; owl:onProperty ?p
# rules:   cls-avf, scm-avf1, scm-avf2
# issues:  For datatype properties, cls-avf should be implemented as a
#          constraint checking that the value is assignable to datatype ?t
#          (dt-not-type).

:cls-avf a spr:Rule ; 
    spr:head """ GRAPH ?g { ?v rdf:type ?t } """ ;
    spr:body """ ?r owl:allValuesFrom ?t; owl:onProperty ?p.
                 ?u rdf:type ?r ; ?p ?v
                 FILTER NOT EXISTS { ?v rdf:type ?t } """ .

:scm-avf1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?r1 rdfs:subClassOf ?r2 } """ ;
    spr:body """ ?r1 owl:allValuesFrom ?t1; owl:onProperty ?p.
                 ?r2 owl:allValuesFrom ?t2; owl:onProperty ?p.
                 ?t1 rdfs:subClassOf ?t2
                 FILTER (?r1 != ?r2)
                 FILTER NOT EXISTS { ?r1 rdfs:subClassOf ?r2 } """ .

:scm-avf2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?r2 rdfs:subClassOf ?r1 } """ ;
    spr:body """ ?r1 owl:allValuesFrom ?t; owl:onProperty ?p1.
                 ?r2 owl:allValuesFrom ?t; owl:onProperty ?p2.
                 ?p1 rdfs:subPropertyOf ?p2
                 FILTER (?r1 != ?r2)
                 FILTER NOT EXISTS { ?r2 rdfs:subClassOf ?r1 } """ .


# VALUE RESTRICTION
#
# syntax:  ?r rdf:type owl:Restriction; owl:onProperty ?p; owl:hasValue ?v
# rules:   cls-hv1, cls-hv2, :scm-hv

:cls-hv1 a spr:Rule ;
    spr:head """ GRAPH ?g { ?u ?p ?v } """ ;
    spr:body """ ?r owl:hasValue ?v; owl:onProperty ?p.
                 ?u rdf:type ?r
                 FILTER NOT EXISTS { ?u ?p ?v } """ .

:cls-hv2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?u rdf:type ?r } """ ;
    spr:body """ ?r owl:hasValue ?v; owl:onProperty ?p.  ?u ?p ?v
                 FILTER NOT EXISTS { ?u rdf:type ?r } """ .

:scm-hv a spr:Rule ;
    spr:head """ GRAPH ?g { ?r1 rdfs:subClassOf ?r2 } """ ;
    spr:body """ ?r1 owl:hasValue ?v; owl:onProperty ?p1.
                 ?r2 owl:hasValue ?v; owl:onProperty ?p2.
                 ?p1 rdfs:subPropertyOf ?p2
                 FILTER (?r1 != ?r2)
                 FILTER NOT EXISTS { ?r1 rdfs:subClassOf ?r2 } """ .


# MAXIMUM CARDINALITY (N <= 1)
#
# syntax:  ?r rdf:type owl:Restriction; owl:onProperty ?p;
#             owl:maxCardinality 1 -- unqualified, OR
#             owl:maxQualifiedCardinality 1; owl:onClass ?c -- qualified
# rules:   cls-maxc1, cls-maxc2, cls-maxqc1, cls-maxqc2, cls-maxqc3, cls-maxqc4
# issues:  For datatype properties, rule cls-maxc2 should be implemented as a
#          constraint checking that ?y1 and ?y2 denote the same value (dt-diff)

:cls-maxc1 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:maxCardinality 0 violated';
                               rdfs:seeAlso ?u, ?p } """ ;
    spr:body """ ?r owl:maxCardinality '0'^^xsd:nonNegativeInteger;
                    owl:onProperty ?p.
                 ?u rdf:type ?x; ?p ?y
                 BIND (#BNODE(owl:maxCardinality, ?u, ?p) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .

:cls-maxc2 a spr:Rule ;
    spr:head """ GRAPH ?g { ?v1 owl:sameAs ?v2 } """ ;
    spr:body """ ?r owl:maxCardinality '1'^^xsd:nonNegativeInteger;
                    owl:onProperty ?p.
                 ?u rdf:type ?r; ?p ?v1, ?v2
                 FILTER NOT EXISTS { ?v1 owl:sameAs ?v2 } """ .

:cls-maxqc1 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:seeAlso ?u, ?p, ?c;
                               rdfs:label
                                    'owl:maxQualifiedCardinality 0 violated'
                          } """ ;
    spr:body """ ?r owl:onProperty ?p; owl:onClass ?c;
                    owl:maxQualifiedCardinality '0'^^xsd:nonNegativeInteger.
                 ?u a ?x; ?p ?y.  ?y a ?c
                 BIND (#BNODE(owl:maxQualifiedCardinality, ?u, ?p, ?c) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .

:cls-maxqc2 a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:seeAlso ?u, ?p;
                               rdfs:label
                                    'owl:maxQualifiedCardinality 0 violated'
                          } """ ;
    spr:body """ ?x owl:onProperty ?p; owl:onClass owl:Thing;
                    owl:maxQualifiedCardinality '0'^^xsd:nonNegativeInteger.
                 ?u a ?x; ?p ?y
                 BIND (#BNODE(owl:maxQualifiedCardinality, ?u, ?p) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .

:cls-maxqc3 a spr:Rule ;
    spr:head """ GRAPH ?g { ?v1 owl:sameAs ?v2 } """ ;
    spr:body """ ?r owl:onProperty ?p; owl:onClass ?c;
                    owl:maxQualifiedCardinality '1'^^xsd:nonNegativeInteger.
                 ?u rdf:type ?r; ?p ?v1, ?v2.  ?v1 rdf:type ?c.  ?v2 rdf:type ?c
                 FILTER (?v1 != ?v2)
                 FILTER NOT EXISTS { ?v1 owl:sameAs ?v2 } """ .

:cls-maxqc4 a spr:Rule ;
    spr:head """ GRAPH ?g { ?v1 owl:sameAs ?v2 } """ ;
    spr:body """ ?r owl:onProperty ?p; owl:onClass owl:Thing;
                    owl:maxQualifiedCardinality '1'^^xsd:nonNegativeInteger.
                 ?u rdf:type ?r; ?p ?v1, ?v2
                 FILTER NOT EXISTS { ?v1 owl:sameAs ?v2 } """ .


# ENUMERATION
#
# syntax:  ?c owl:oneOf ( ?i1 ... ?iN )
# rules:   cls-oo
# notes:   Rule cls-oo implemented through recursive navigation of the value
#          list by rules cls-oo-s (start) and cls-oo-r (recursion).

:cls-oo-s a spr:Rule ;
    spr:head """ GRAPH ?g { ?v1 rdf:type ?c.  ?c sys:expandOneOf ?l2 } """ ;
    spr:body """ ?c owl:oneOf ?l1.  ?l1 rdf:first ?v1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?c sys:expandOneOf ?l2 }
                 BIND (!EXISTS { ?v1 rdf:type ?c } AS ?_emit1) """ .

:cls-oo-r a spr:Rule ;
    spr:head """ GRAPH ?g { ?v1 rdf:type ?c .  ?c sys:expandOneOf ?l2 } """ ;
    spr:body """ ?c sys:expandOneOf ?l1.  ?l1 rdf:first ?v1; rdf:rest ?l2
                 FILTER NOT EXISTS { ?c sys:expandOneOf ?l2 }
                 BIND (!EXISTS { ?v1 rdf:type ?c } AS ?_emit1) """ .


# COMPLEMENT
#
# syntax:  ?c1 owl:complementOf ?c2
# rules:   cls-com

:cls-com a spr:Rule ; # constraint
    spr:head """ GRAPH ?g { ?b rdf:type sys:Inconsistency;
                               rdfs:label 'owl:complementOf violated';
                               rdfs:seeAlso ?x, ?c1, ?c2 } """ ;
    spr:body """ ?c1 owl:complementOf ?c2.  ?x a ?c1, ?c2
                 BIND (#BNODE(owl:complementOf, ?x, ?c1, ?c2) AS ?b)
                 FILTER NOT EXISTS { ?b rdf:type sys:Inconsistency } """ .
